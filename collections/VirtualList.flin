// VirtualList.flin - Virtualized list for large datasets

// Props with defaults
items = props.items || []
itemHeight = props.itemHeight || 40
height = props.height || 400
renderItem = props.renderItem || nil
onScroll = props.onScroll || nil
overscan = props.overscan || 3
gap = props.gap || 0

// State
scrollTop = 0
containerRef = nil

// Computed values
totalHeight = items.length * (itemHeight + gap) - gap
visibleCount = Math.ceil(height / (itemHeight + gap)) + 1
startIndex = Math.max(0, Math.floor(scrollTop / (itemHeight + gap)) - overscan)
endIndex = Math.min(items.length, startIndex + visibleCount + overscan * 2)
offsetY = startIndex * (itemHeight + gap)

// Get visible items
visibleItems = items.slice(startIndex, endIndex).map(|item, index| ({
    item: item,
    index: startIndex + index,
    style: {
        position: "absolute",
        top: "{(startIndex + index) * (itemHeight + gap)}px",
        left: "0",
        right: "0",
        height: "{itemHeight}px"
    }
}))

// CSS classes
containerClass = "virtual-list"
viewportClass = "virtual-list-viewport"
contentClass = "virtual-list-content"
itemClass = "virtual-list-item"

// Handlers
handleScroll = |e| {
    newScrollTop = e.target.scrollTop
    scrollTop = newScrollTop

    if onScroll {
        onScroll({
            scrollTop: newScrollTop,
            scrollHeight: totalHeight,
            clientHeight: height,
            startIndex: startIndex,
            endIndex: endIndex
        })
    }
}

// Scroll to specific index
scrollToIndex = |index, behavior = "auto"| {
    if containerRef {
        targetTop = index * (itemHeight + gap)
        containerRef.scrollTo({
            top: targetTop,
            behavior: behavior
        })
    }
}

// Scroll to top
scrollToTop = |behavior = "auto"| {
    scrollToIndex(0, behavior)
}

// Scroll to bottom
scrollToBottom = |behavior = "auto"| {
    scrollToIndex(items.length - 1, behavior)
}

// Default render item if none provided
defaultRenderItem = |item, index| {
    <div class={itemClass}>
        {item.label || item.toString()}
    </div>
}

// Get the render function
itemRenderer = renderItem || defaultRenderItem

<div class={containerClass}>
    <div
        class={viewportClass}
        style="height: {height}px"
        onScroll={handleScroll}
        ref={|el| { containerRef = el }}
    >
        <div
            class={contentClass}
            style="height: {totalHeight}px"
        >
            {visibleItems.map(|{ item, index, style }| (
                <div
                    key={index}
                    class="virtual-list-item-wrapper"
                    style={style}
                >
                    {itemRenderer(item, index)}
                </div>
            ))}
        </div>
    </div>

    {items.length == 0 ? (
        <div class="virtual-list-empty">
            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <line x1="9" y1="9" x2="15" y2="15"></line>
                <line x1="15" y1="9" x2="9" y2="15"></line>
            </svg>
            <span>No items to display</span>
        </div>
    ) : nil}

    <div class="virtual-list-info">
        Showing {startIndex + 1} - {Math.min(endIndex, items.length)} of {items.length}
    </div>
</div>

<style scoped>
.virtual-list {
    position: relative;
    width: 100%;
}

.virtual-list-viewport {
    overflow-y: auto;
    overflow-x: hidden;
    border: 1px solid var(--flin-neutral-200);
    border-radius: var(--flin-radius-md);
    background: var(--flin-bg);
}

.virtual-list-viewport::-webkit-scrollbar {
    width: 8px;
}

.virtual-list-viewport::-webkit-scrollbar-track {
    background: var(--flin-neutral-100);
    border-radius: 4px;
}

.virtual-list-viewport::-webkit-scrollbar-thumb {
    background: var(--flin-neutral-300);
    border-radius: 4px;
}

.virtual-list-viewport::-webkit-scrollbar-thumb:hover {
    background: var(--flin-neutral-400);
}

.virtual-list-content {
    position: relative;
    width: 100%;
}

.virtual-list-item-wrapper {
    box-sizing: border-box;
}

.virtual-list-item {
    display: flex;
    align-items: center;
    padding: 0 16px;
    height: 100%;
    border-bottom: 1px solid var(--flin-neutral-100);
    transition: background var(--flin-transition-fast);
}

.virtual-list-item:hover {
    background: var(--flin-neutral-50);
}

.virtual-list-empty {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px;
    padding: 48px 24px;
    color: var(--flin-neutral-400);
    text-align: center;
}

.virtual-list-info {
    padding: 8px 12px;
    font-size: 12px;
    color: var(--flin-neutral-500);
    text-align: right;
    border-top: 1px solid var(--flin-neutral-200);
    background: var(--flin-neutral-50);
    border-radius: 0 0 var(--flin-radius-md) var(--flin-radius-md);
}
</style>
