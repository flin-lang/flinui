// InputMask.flin - FlinUI Input Mask Component
// Masked input for phone, credit card, date, and custom formats

// Props with defaults
value = props.value || ""
mask = props.mask || ""
maskChar = props.maskChar || "_"
placeholder = props.placeholder || ""
disabled = props.disabled || false
type = props.type || "text"
guide = props.guide || true
keepCharPositions = props.keepCharPositions || false
showMask = props.showMask || true
onChange = props.onChange
onComplete = props.onComplete
onFocus = props.onFocus
onBlur = props.onBlur

// Preset masks
presets = {
    "phone": "(999) 999-9999",
    "phone-intl": "+9 (999) 999-9999",
    "credit-card": "9999 9999 9999 9999",
    "credit-card-amex": "9999 999999 99999",
    "date": "99/99/9999",
    "date-iso": "9999-99-99",
    "time": "99:99",
    "time-seconds": "99:99:99",
    "ssn": "999-99-9999",
    "zip": "99999",
    "zip-plus4": "99999-9999",
    "currency": "$9,999,999.99",
    "percentage": "999%",
    "ip-address": "999.999.999.999"
}

// State
rawValue = value
maskedValue = ""
isFocused = false
cursorPosition = 0
isComplete = false

// Get active mask (from preset or custom)
getActiveMask = {
    presets[mask] || mask
}

// Mask character definitions
// 9 = digit, a = letter, A = uppercase letter, * = alphanumeric
isDefinitionChar = {
    char = event;
    char == "9" || char == "a" || char == "A" || char == "*"
}

// Validate character against definition
validateChar = {
    char = event.char;
    definition = event.definition;

    {if definition == "9"}
        /[0-9]/.test(char)
    {else if definition == "a"}
        /[a-zA-Z]/.test(char)
    {else if definition == "A"}
        /[a-zA-Z]/.test(char)
    {else if definition == "*"}
        /[a-zA-Z0-9]/.test(char)
    {else}
        false
    {/if}
}

// Transform character if needed (e.g., uppercase)
transformChar = {
    char = event.char;
    definition = event.definition;

    {if definition == "A"}
        char.toUpperCase()
    {else}
        char
    {/if}
}

// Apply mask to raw value
applyMask = {
    activeMask = getActiveMask();
    result = "";
    rawIndex = 0;

    {for i in 0..activeMask.length}
        maskChar = activeMask[i];

        {if isDefinitionChar(maskChar)}
            {if rawIndex < rawValue.length}
                inputChar = rawValue[rawIndex];
                {if validateChar({ char: inputChar, definition: maskChar })}
                    result = result ++ transformChar({ char: inputChar, definition: maskChar });
                    rawIndex = rawIndex + 1
                {else}
                    // Invalid char, skip or add placeholder
                    {if guide && showMask}
                        result = result ++ props.maskChar
                    {/if}
                    rawIndex = rawIndex + 1
                {/if}
            {else if guide && showMask && isFocused}
                result = result ++ props.maskChar
            {/if}
        {else}
            // Literal character in mask
            {if rawIndex < rawValue.length || (guide && showMask && isFocused)}
                result = result ++ maskChar
            {/if}
        {/if}
    {/for}

    maskedValue = result;
    checkComplete()
}

// Extract raw value from masked input
extractRaw = {
    input = event;
    activeMask = getActiveMask();
    result = "";
    inputIndex = 0;

    {for i in 0..activeMask.length}
        {if inputIndex >= input.length}
            break
        {/if}

        maskChar = activeMask[i];
        inputChar = input[inputIndex];

        {if isDefinitionChar(maskChar)}
            {if inputChar != props.maskChar && validateChar({ char: inputChar, definition: maskChar })}
                result = result ++ inputChar
            {/if}
            inputIndex = inputIndex + 1
        {else}
            // Skip literal characters
            {if inputChar == maskChar}
                inputIndex = inputIndex + 1
            {/if}
        {/if}
    {/for}

    result
}

// Check if input is complete
checkComplete = {
    activeMask = getActiveMask();
    requiredLength = 0;

    {for i in 0..activeMask.length}
        {if isDefinitionChar(activeMask[i])}
            requiredLength = requiredLength + 1
        {/if}
    {/for}

    wasComplete = isComplete;
    isComplete = rawValue.length == requiredLength;

    {if isComplete && !wasComplete && onComplete}
        onComplete({
            raw: rawValue,
            masked: maskedValue,
            isValid: validateInput()
        })
    {/if}
}

// Validate complete input (basic validation)
validateInput = {
    activeMask = getActiveMask();

    // Date validation
    {if mask == "date" || mask == "date-iso"}
        parts = rawValue.match(/.{1,2}/g);
        {if parts && parts.length >= 3}
            month = parseInt(mask == "date" ? parts[0] : parts[1]);
            day = parseInt(mask == "date" ? parts[1] : parts[2]);
            year = parseInt(mask == "date" ? parts[2] : parts[0]);
            month >= 1 && month <= 12 && day >= 1 && day <= 31
        {else}
            false
        {/if}
    // Time validation
    {else if mask == "time" || mask == "time-seconds"}
        parts = rawValue.match(/.{1,2}/g);
        {if parts && parts.length >= 2}
            hours = parseInt(parts[0]);
            minutes = parseInt(parts[1]);
            hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59
        {else}
            false
        {/if}
    {else}
        true
    {/if}
}

// Handle input change
handleInput = {
    inputValue = event.target.value;
    newRaw = extractRaw(inputValue);

    // Validate each character
    activeMask = getActiveMask();
    validatedRaw = "";
    definitionIndex = 0;

    {for i in 0..newRaw.length}
        // Find next definition char in mask
        {while definitionIndex < activeMask.length && !isDefinitionChar(activeMask[definitionIndex])}
            definitionIndex = definitionIndex + 1
        {/while}

        {if definitionIndex < activeMask.length}
            char = newRaw[i];
            definition = activeMask[definitionIndex];

            {if validateChar({ char: char, definition: definition })}
                validatedRaw = validatedRaw ++ transformChar({ char: char, definition: definition })
            {/if}
            definitionIndex = definitionIndex + 1
        {/if}
    {/for}

    rawValue = validatedRaw;
    applyMask();

    {if onChange}
        onChange({
            raw: rawValue,
            masked: maskedValue,
            isComplete: isComplete,
            isValid: validateInput()
        })
    {/if}
}

// Handle keydown for special keys
handleKeydown = {
    {if event.key == "Backspace" && keepCharPositions}
        event.preventDefault();
        // Handle backspace with position keeping
        curPos = event.target.selectionStart;
        {if curPos > 0}
            activeMask = getActiveMask();
            // Find the actual character position
            newRaw = rawValue.slice(0, -1);
            rawValue = newRaw;
            applyMask();
            {if onChange}
                onChange({
                    raw: rawValue,
                    masked: maskedValue,
                    isComplete: isComplete,
                    isValid: validateInput()
                })
            {/if}
        {/if}
    {/if}
}

// Handle focus
handleFocus = {
    isFocused = true;
    applyMask();
    {if onFocus}
        onFocus(event)
    {/if}
}

// Handle blur
handleBlur = {
    isFocused = false;
    {if !showMask || rawValue == ""}
        maskedValue = rawValue
    {/if}
    applyMask();
    {if onBlur}
        onBlur(event)
    {/if}
}

// Get placeholder from mask
getPlaceholder = {
    {if placeholder != ""}
        placeholder
    {else if showMask}
        activeMask = getActiveMask();
        activeMask.split("").map(c => {
            {if isDefinitionChar(c)}
                maskChar
            {else}
                c
            {/if}
        }).join("")
    {else}
        ""
    {/if}
}

// Initialize mask on mount
initMask = {
    {if value != ""}
        rawValue = extractRaw(value);
        applyMask()
    {/if}
}

// Call init
initMask()

// Get icon based on mask type
getMaskIcon = {
    {if mask == "phone" || mask == "phone-intl"}
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/>
        </svg>
    {else if mask == "credit-card" || mask == "credit-card-amex"}
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="1" y="4" width="22" height="16" rx="2"/>
            <line x1="1" y1="10" x2="23" y2="10"/>
        </svg>
    {else if mask == "date" || mask == "date-iso"}
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <rect x="3" y="4" width="18" height="18" rx="2"/>
            <line x1="16" y1="2" x2="16" y2="6"/>
            <line x1="8" y1="2" x2="8" y2="6"/>
            <line x1="3" y1="10" x2="21" y2="10"/>
        </svg>
    {else if mask == "time" || mask == "time-seconds"}
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="10"/>
            <polyline points="12 6 12 12 16 14"/>
        </svg>
    {else}
        null
    {/if}
}

// Compute classes
disabledClass = match disabled { true -> " input-mask-disabled", _ -> "" }
focusedClass = match isFocused { true -> " input-mask-focused", _ -> "" }
completeClass = match isComplete { true -> " input-mask-complete", _ -> "" }
hasIconClass = match getMaskIcon() != null { true -> " input-mask-has-icon", _ -> "" }

<div class={"input-mask" ++ disabledClass ++ focusedClass ++ completeClass ++ hasIconClass}>
    <div class="input-mask-wrapper">
        {if getMaskIcon() != null}
            <span class="input-mask-icon" aria-hidden="true">
                {getMaskIcon()}
            </span>
        {/if}

        <input
            type={type}
            class="input-mask-input"
            value={maskedValue}
            placeholder={getPlaceholder()}
            disabled={disabled}
            input={handleInput}
            keydown={handleKeydown}
            focus={handleFocus}
            blur={handleBlur}
            aria-label={placeholder || mask}
            autocomplete="off"
            spellcheck="false"
        >

        {if isComplete && !disabled}
            <span class="input-mask-check" aria-label="Complete">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="20 6 9 17 4 12"/>
                </svg>
            </span>
        {/if}

        {if rawValue != "" && !disabled && !isComplete}
            <button
                type="button"
                class="input-mask-clear"
                click={() => {
                    rawValue = "";
                    maskedValue = "";
                    isComplete = false;
                    {if onChange}
                        onChange({ raw: "", masked: "", isComplete: false, isValid: false })
                    {/if}
                }}
                aria-label="Clear"
            >
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round">
                    <path d="M18 6L6 18M6 6l12 12"/>
                </svg>
            </button>
        {/if}
    </div>

    {if guide && mask != ""}
        <div class="input-mask-format">
            Format: {getActiveMask().replace(/9/g, "#").replace(/[aA]/g, "X").replace(/\*/g, "*")}
        </div>
    {/if}
</div>

<style scoped>
.input-mask {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: var(--flin-space-1);
}

.input-mask-wrapper {
    position: relative;
    display: flex;
    align-items: center;
}

.input-mask-icon {
    position: absolute;
    left: var(--flin-space-3);
    color: var(--flin-fg-muted);
    pointer-events: none;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1;
}

.input-mask-focused .input-mask-icon {
    color: var(--flin-primary);
}

.input-mask-input {
    width: 100%;
    height: 40px;
    padding: var(--flin-space-2) var(--flin-space-10) var(--flin-space-2) var(--flin-space-3);
    font-family: var(--flin-font-mono);
    font-size: var(--flin-text-base);
    letter-spacing: 0.05em;
    color: var(--flin-fg);
    background-color: var(--flin-bg);
    border: 1px solid var(--flin-neutral-300);
    border-radius: var(--flin-radius-md);
    transition: all var(--flin-transition-fast);
    outline: none;
}

.input-mask-has-icon .input-mask-input {
    padding-left: var(--flin-space-10);
}

.input-mask-input::placeholder {
    color: var(--flin-fg-muted);
    font-family: var(--flin-font-mono);
    letter-spacing: 0.1em;
}

.input-mask-input:hover:not(:disabled) {
    border-color: var(--flin-neutral-400);
}

.input-mask-focused .input-mask-input {
    border-color: var(--flin-primary);
    box-shadow: 0 0 0 3px var(--flin-primary-light);
}

.input-mask-complete .input-mask-input {
    border-color: var(--flin-success);
}

.input-mask-complete.input-mask-focused .input-mask-input {
    box-shadow: 0 0 0 3px var(--flin-success-light);
}

.input-mask-check {
    position: absolute;
    right: var(--flin-space-3);
    color: var(--flin-success);
    display: flex;
    align-items: center;
    justify-content: center;
    animation: check-in 0.2s ease-out;
}

@keyframes check-in {
    from {
        opacity: 0;
        transform: scale(0.5);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

.input-mask-clear {
    position: absolute;
    right: var(--flin-space-2);
    display: flex;
    align-items: center;
    justify-content: center;
    width: 24px;
    height: 24px;
    padding: 0;
    background: transparent;
    border: none;
    border-radius: var(--flin-radius-sm);
    color: var(--flin-fg-muted);
    cursor: pointer;
    transition: all var(--flin-transition-fast);
}

.input-mask-clear:hover {
    background-color: var(--flin-neutral-100);
    color: var(--flin-danger);
}

.input-mask-format {
    font-size: var(--flin-text-xs);
    color: var(--flin-fg-muted);
    font-family: var(--flin-font-mono);
}

/* Disabled state */
.input-mask-disabled .input-mask-input {
    background-color: var(--flin-bg-muted);
    color: var(--flin-fg-muted);
    cursor: not-allowed;
}

.input-mask-disabled .input-mask-icon {
    color: var(--flin-neutral-400);
}

/* Dark mode */
[data-theme="dark"] .input-mask-clear:hover {
    background-color: var(--flin-neutral-700);
}
</style>
