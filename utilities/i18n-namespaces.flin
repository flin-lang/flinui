// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FLIN i18n â€” Namespace Approach (500-10,000+ translation keys)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// ğŸ“– USAGE:
//   1. Copy this file into your project
//   2. Create translation JSON files in /translations/ directory:
//      translations/en-common.json
//      translations/en-products.json
//      translations/fr-common.json
//      translations/fr-products.json
//   3. Load namespaces with: load_namespace("common")
//   4. Use t("key") just like simple version
//
// âœ… GOOD FOR:
//   â€¢ E-commerce sites (1000+ products)
//   â€¢ Large apps (Google-scale, 10,000+ keys)
//   â€¢ Multi-page apps with different translation needs per page
//   â€¢ Apps where translations are managed by external tools
//
// âŒ NOT GOOD FOR:
//   â€¢ Small apps (< 500 keys) â€” use i18n-simple.flin instead
//   â€¢ Static sites without server
//
// ğŸ”— INSPIRED BY:
//   â€¢ Next.js next-intl (namespace splitting)
//   â€¢ Nuxt i18n (lazy loading)
//   â€¢ React-i18next (namespace architecture)
//
// ğŸš€ PERFORMANCE:
//   â€¢ Only loads translations you need
//   â€¢ Caches loaded namespaces
//   â€¢ Parallel loading for multiple namespaces
//   â€¢ Scales to 10,000+ keys without memory issues
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1. STATE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

currentLang = "en"
translations = [:]           // Empty initially, populated by load_namespace()
loadedNamespaces = []        // Track loaded namespaces: ["en-common", "fr-common"]
loadingNamespaces = []       // Track currently loading to avoid duplicates
translationsBaseUrl = "/translations"  // Base URL for JSON files

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 2. NAMESPACE LOADING (Lazy Loading with Caching)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Load a translation namespace from server
// Example: load_namespace("common") â†’ fetches /translations/en-common.json
fn load_namespace(namespace) {
    namespace_key = currentLang + "-" + namespace

    // Already loaded? Skip
    if loadedNamespaces.includes(namespace_key) {
        return
    }

    // Currently loading? Skip
    if loadingNamespaces.includes(namespace_key) {
        return
    }

    // Mark as loading
    loadingNamespaces.push(namespace_key)

    // Fetch from server
    url = translationsBaseUrl + "/" + namespace_key + ".json"

    // Async fetch (FLIN handles this in onMount)
    response = fetch(url)

    if response.ok {
        data = response.json

        // Initialize language dict if needed
        if translations[currentLang] == none {
            translations[currentLang] = [:]
        }

        // Merge translations into main dict
        for [key, value] in data {
            translations[currentLang][key] = value
        }

        // Mark as loaded
        loadedNamespaces.push(namespace_key)
    } else {
        console.log("Failed to load namespace: " + namespace_key)
    }

    // Remove from loading list
    loadingNamespaces = loadingNamespaces.filter(fn(n) { n != namespace_key })
}

// Load multiple namespaces in parallel
// Example: load_namespaces(["common", "products", "checkout"])
fn load_namespaces(namespace_list) {
    for ns in namespace_list {
        load_namespace(ns)
    }
}

// Auto-load namespaces based on current URL
// Example: /products â†’ loads "common" + "products"
//          /checkout â†’ loads "common" + "checkout"
fn auto_load_namespaces() {
    path = window.location.pathname

    // Always load common translations
    load_namespace("common")

    // Load page-specific namespaces
    if path.includes("/products") || path.includes("/product/") {
        load_namespace("products")
    } else if path.includes("/checkout") {
        load_namespace("checkout")
    } else if path.includes("/admin") {
        load_namespace("admin")
    } else if path.includes("/docs") {
        load_namespace("docs")
    } else if path == "/" || path.includes("/home") {
        load_namespace("home")
    }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 3. TRANSLATION FUNCTIONS (Same API as i18n-simple.flin)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Simple translation lookup with nested key support
// Example: t("nav.home") â†’ "Home"
fn t(key) {
    parts = key.split(".")
    dict = translations[currentLang]

    // Navigate nested keys
    for part in parts {
        if dict == none {
            // Try fallback to English
            dict = translations["en"]
            for p in parts {
                if dict == none { return key }
                dict = dict[p]
            }
            return dict ?? key
        }
        dict = dict[part]
    }

    // Fallback to English if not found in current language
    if dict == none {
        fallback_dict = translations["en"]
        for part in parts {
            if fallback_dict == none { return key }
            fallback_dict = fallback_dict[part]
        }
        return fallback_dict ?? key
    }

    return dict
}

// Translation with variable interpolation
// Example: t_with("greeting.hello", ["name": "Juste"]) â†’ "Hello Juste!"
fn t_with(key, vars) {
    text = t(key)

    // Replace {{var}} placeholders
    for [k, v] in vars {
        placeholder = "{{" + k + "}}"
        text = text.replace(placeholder, v.to_text())
    }

    return text
}

// Plural helper with count-based rules
// Example: plural(5, "items.count") â†’ "5 items"
fn plural(count, key) {
    rules = t(key)

    // If t() returned a plain string (no plural rules), just return it
    if rules.type() == "text" {
        return rules
    }

    // Apply plural rules
    if count == 0 && rules["zero"] != none {
        return t_with(rules["zero"], ["count": count])
    }

    if count == 1 && rules["one"] != none {
        return t_with(rules["one"], ["count": count])
    }

    // Default to "other" form
    other_form = rules["other"] ?? rules
    return t_with(other_form, ["count": count])
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 4. CURRENCY FORMATTING
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn format_currency(amount, currency) {
    configs = [
        "USD": ["symbol": "$", "position": "before"],
        "EUR": ["symbol": "â‚¬", "position": "after"],
        "GBP": ["symbol": "Â£", "position": "before"],
        "JPY": ["symbol": "Â¥", "position": "before"],
        "CNY": ["symbol": "Â¥", "position": "before"],
        "XOF": ["symbol": "CFA", "position": "after"],  // West African franc
        "XAF": ["symbol": "FCFA", "position": "after"], // Central African franc
        "MAD": ["symbol": "DH", "position": "after"],   // Moroccan dirham
        "EGP": ["symbol": "EÂ£", "position": "before"],  // Egyptian pound
        "ZAR": ["symbol": "R", "position": "before"]    // South African rand
    ]

    config = configs[currency] ?? configs["USD"]
    formatted = amount.format(2)  // Format with 2 decimals

    if config["position"] == "before" {
        return config["symbol"] + formatted
    } else {
        return formatted + " " + config["symbol"]
    }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 5. DATE FORMATTING (uses FLIN's built-in locale-aware formatting)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn format_date(date, format_str) {
    return date.format(format_str)
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 6. LANGUAGE DETECTION & PERSISTENCE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

fn detect_language() {
    // 1. Check localStorage first (user preference)
    stored = localStorage.get("flin_lang")
    if stored != none {
        return stored
    }

    // 2. Check browser language
    browser_lang = navigator.language.split("-")[0]  // "en-US" â†’ "en"
    return browser_lang ?? "en"
}

fn set_language(lang_code) {
    old_lang = currentLang
    currentLang = lang_code

    localStorage.set("flin_lang", lang_code)
    document.documentElement.setAttribute("lang", lang_code)

    // Set text direction for RTL languages
    if lang_code == "ar" || lang_code == "he" {
        document.documentElement.setAttribute("dir", "rtl")
    } else {
        document.documentElement.setAttribute("dir", "ltr")
    }

    // Reload namespaces for new language
    if old_lang != lang_code {
        // Clear loaded namespaces for old language
        loadedNamespaces = loadedNamespaces.filter(fn(ns) {
            !ns.starts_with(old_lang + "-")
        })

        // Reload current page's namespaces
        auto_load_namespaces()
    }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 7. AUTO-DETECT & AUTO-LOAD ON PAGE LOAD
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

onMount {
    currentLang = detect_language()
    set_language(currentLang)
    auto_load_namespaces()  // Load translations for current page
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 8. UTILITY FUNCTIONS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// Check if a namespace is loaded
fn is_namespace_loaded(namespace) {
    namespace_key = currentLang + "-" + namespace
    return loadedNamespaces.includes(namespace_key)
}

// Get list of all loaded namespaces for current language
fn get_loaded_namespaces() {
    prefix = currentLang + "-"
    return loadedNamespaces.filter(fn(ns) {
        ns.starts_with(prefix)
    }).map(fn(ns) {
        ns.replace(prefix, "")
    })
}

// Preload namespaces in background (for performance)
// Example: preload_namespaces(["products", "checkout"])
fn preload_namespaces(namespace_list) {
    for ns in namespace_list {
        load_namespace(ns)
    }
}
